/*
 * main.c
 * Main program for TIVA MCU
 * Exercise 8.2.1 Generating voltages Using a DAC
 *
 * Station 13
 * Lab Team:
 * Emmanuel Ramos
 * Reynaldo Belfort
 */

//Pin configuration
//7  6  5  4  3  2  1  0
//D7,D6,D5,D4,D3,D2,D1,D0 	- port B GPIOs - Data Port
//RS,R/W,E,PUSHB       		- port A GPIOs - Control Port + LCD Module Push Button
//-,-,-,-,D7,D6,D5,D4		- port D - Second Half of DAC data pins MSB
//-,-,-,-,D3,D2,D1,D0		- port F - First Half of DAC data pins LSB

//MCU objective #1: Change the current DAC value each 1 second, following the DAC table.
//				 The current DAC Value must be displayed on LCD
//MCU objective #2: Produce a sinusoidal wave with freq: 500Hz adn peak-to-peak voltage of 3.3V

//MCU objective #1 Pseudocode - Main program
//Initialize DAC Value table (array, hex values)
//<<Initialize LCD>>
//<<Initialize Timer, register ISR>>
//<<Initialize DAC pins>>
//<<Display LCD welcome message>>

//Main loop
	//<<Send dacTable[dac_counter]>>
	//<<Display current DAC Value>>
	//<<If dac_counter == 12>>
		//Reset dac_counter to 0

//<<Send dacTable[dac_counter]>>
	//Set dacTable[dac_counter][0] (4 LSB bits) on port F
	//Set dacTable[dac_counter][1] (4 MSB bits) on port D

//Pseudocode - Timer ISR
//Clear timer interrupt flag
//Increment dac_counter


#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include "driverlib/gpio.h"
#include "driverlib/pin_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/interrupt.h"
#include "driverlib/debug.h"
#include "driverlib/pwm.h"
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "inc/hw_gpio.h"
#include "inc/hw_ints.h"

//Custom libraries
#include "MIL_LCD_lib.h"
#include "tivaUtils.h"

//DAC Look-up Table
uint8_t dacTable[12][2] = {
		{0x0,0x0},
		{0x1,0x7},
		{0x2,0xE},
		{0x4,0x5},
		{0x5,0xC},
		{0x7,0x3},
		{0x8,0xA},
		{0xA,0x1},
		{0xB,0x8},
		{0xC,0xF},
		{0xE,0x6},
		{0xF,0xF},
};

//Constant definition for LCD positions


//Constant definitions for PWM Module
#define DESIRED_PWM_FRECUENCY 440 //In Hz
#define DUTY_CYCLE 0.50 //% DutyCycle (decimal value)


//Global variables

//Define flags

void ENTER_PUSHB_INTERRUPT(){

	setDelay(30); //Software deboncing

	//Modify values according to the current state of the Digital Clock
	switch(CLOCK_STATE){
		case 0: //Clock setup state
			//Change to next positon for time, date or alarm time
			VALUE_POSITION++;
			break;
		case 1: //Clock & Alarm display state
			CURRENT_DISPLAY_INFO = CURRENT_DISPLAY_INFO ^ 0x01; //Toggle flag value to change what is displayed on LCD
			clearLCD(); //So LCD screen any old messages that the new display information won't overrride
			break;
		case 2: //Alarm triggered state
			ENTER_PUSH_FLAG = true; //Send signal to stop alarm
			break;
	}

	//Clear interrupt flag
	GPIOIntClear(GPIO_PORTA_BASE, GPIO_PIN_4);
}

void UP_DOWN_PUSHB_INTERRUPT(){

	setDelay(30); //Software debouncing

	//Get which button was interrumped
	UP_DOWN_PUSH_VAL = GPIOIntStatus(GPIO_PORTF_BASE,true);

	//Clear interrupt flag
	GPIOIntClear(GPIO_PORTF_BASE, GPIO_PIN_4 | GPIO_PIN_0);
}

int main(void) {

	//--------------------MCU Initialization------------------------
		//Set MCU to 40MHz
		SysCtlClockSet(SYSCTL_SYSDIV_5 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN | SYSCTL_XTAL_16MHZ);

		//initialize I2C module 3
		_globalSystemClock = SysCtlClockGet();
		InitializeI2C();

		//--------Push button initialization----------
		SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);  //Enable PB F0 & F4
		SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);  //Enable ENTER PB A4

		HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;
		HWREG(GPIO_PORTF_BASE + GPIO_O_CR) |= 0x01;
		HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = 0;
		GPIODirModeSet(GPIO_PORTF_BASE, GPIO_PIN_4|GPIO_PIN_0, GPIO_DIR_MODE_IN);
		GPIOPadConfigSet(GPIO_PORTF_BASE, GPIO_PIN_4|GPIO_PIN_0, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);
		//Port F interrupts
		GPIOIntRegister(GPIO_PORTF_BASE, UP_DOWN_PUSHB_INTERRUPT);
		GPIOIntTypeSet(GPIO_PORTF_BASE, GPIO_PIN_4|GPIO_PIN_0, GPIO_RISING_EDGE);
		//Port A interrupts (LCD Module Push Button)
		GPIOIntRegister(GPIO_PORTA_BASE, ENTER_PUSHB_INTERRUPT);
		GPIOIntTypeSet(GPIO_PORTA_BASE, GPIO_PIN_4, GPIO_RISING_EDGE);
		GPIODirModeSet(GPIO_PORTA_BASE, GPIO_PIN_4, GPIO_DIR_MODE_IN);
		GPIOPadConfigSet(GPIO_PORTA_BASE, GPIO_PIN_4, GPIO_STRENGTH_4MA, GPIO_PIN_TYPE_STD_WPU); //Set up pull down push button
		//Interrupt enable
		GPIOIntEnable(GPIO_PORTF_BASE, GPIO_PIN_4|GPIO_PIN_0);
		GPIOIntEnable(GPIO_PORTA_BASE, GPIO_PIN_4);
		//--------------------

//		//------------PWM Initialization (For buzzer)------------
//		 //Clock the PWM module by the system clock
//		 SysCtlPWMClockSet(SYSCTL_PWMDIV_32); //Divide system clock by 32 to run the PWM at 1.25MHz
//
//		 //Enabling PWM1 module and Port D
//		 SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM1);
//		 SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD); //Port where the PWM pin will be selected
//
//		 //Selecting PWM generator 0 and port D pin 0 (PD0) aa a PWM output pin for module one
//		 GPIOPinTypePWM(GPIO_PORTD_BASE, GPIO_PIN_0); //Set Port D pin 0 as output //TODO Checkout which ports can be used for PWM functionallity
//		 GPIOPinConfigure(GPIO_PD0_M1PWM0); //Select PWM Generator 0
//
//		 //Determine period register load value
//		 pwmClockFreq = SysCtlClockGet() / 32; //TODO as Isnt the same as ROM_SysCtlPWMClockSet(SYSCTL_PWMDIV_64);? Is something being repeated?
//		 pwmLoadValue = (pwmClockFreq / DESIRED_PWM_FRECUENCY) - 1; //Load Value = (PWMGeneratorClock * DesiredPWMPeriod) - 1
//		 PWMGenConfigure(PWM1_BASE, PWM_GEN_0, PWM_GEN_MODE_DOWN); //Set a count-down generator type
//		 PWMGenPeriodSet(PWM1_BASE, PWM_GEN_0, pwmLoadValue); //Set PWM period determined by the load value
//
//		 //Setup PWM Pulse Width Duty Cycle
//		 PWMPulseWidthSet(PWM1_BASE, PWM_OUT_0, pwmLoadValue * DUTY_CYCLE);
//		 PWMOutputState(PWM1_BASE, PWM_OUT_0_BIT, false); //Start with the PWM Gen off
//		 PWMGenEnable(PWM1_BASE, PWM_GEN_0); //Enable PWM Generator
//		 //-------------------------------------------

		 //------------PWM Initialization (For buzzer)------------
		 		 //Clock the PWM module by the system clock
		 		 SysCtlPWMClockSet(SYSCTL_PWMDIV_32); //Divide system clock by 32 to run the PWM at 1.25MHz

		 		 //Enabling PWM1 module and Port D
		 		 SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM1);
//		 		 SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF); 	//Port is already initialized above

		 		 //Selecting PWM generator 0 and port D pin 0 (PD0) aa a PWM output pin for module one
		 		 GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_1); 	//Set Port D pin 0 as output //TODO Checkout which ports can be used for PWM functionallity
		 		 GPIOPinConfigure(GPIO_PF1_M1PWM5); 			//Select PWM Generator 0

		 		 //Determine period register load value
		 		 pwmClockFreq = SysCtlClockGet() / 32; //TODO as Isnt the same as ROM_SysCtlPWMClockSet(SYSCTL_PWMDIV_64);? Is something being repeated?
		 		 pwmLoadValue = (pwmClockFreq / DESIRED_PWM_FRECUENCY) - 1; 	//Load Value = (PWMGeneratorClock * DesiredPWMPeriod) - 1
		 		 PWMGenConfigure(PWM1_BASE, PWM_GEN_2, PWM_GEN_MODE_DOWN); 		//Set a count-down generator type
		 		 PWMGenPeriodSet(PWM1_BASE, PWM_GEN_2, pwmLoadValue); 			//Set PWM period determined by the load value

		 		 //Setup PWM Pulse Width Duty Cycle
		 		 PWMPulseWidthSet(PWM1_BASE, PWM_OUT_5, pwmLoadValue * DUTY_CYCLE);
		 		 PWMOutputState(PWM1_BASE, PWM_OUT_5_BIT, false); 		//Start with the PWM Gen off
		 		 PWMGenEnable(PWM1_BASE, PWM_GEN_2); 					//Enable PWM Generator
		 		 //-------------------------------------------

		//--------LCD Setup--------

		SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);  // Enable, RS and R/W port for LCD Display
		SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);  // Data port for LCD display
		//Set LCD pins as outputs
		GPIOPinTypeGPIOOutput(GPIO_PORTA_BASE, GPIO_PIN_7|GPIO_PIN_6|GPIO_PIN_5);
		GPIOPinTypeGPIOOutput(GPIO_PORTB_BASE, ENTIRE_PORT);

		//-------------------------

		//Variable initialization
		time_sec = time_min = time_hour = date_day = date_month = date_year = alarm_sec = alarm_min = alarm_hour = 0;
		CLOCK_STATE = 0;
    //--------------------------------------------------------

    //----LCD screen initialization----
    initializeLCD();
    DisplayTimeDateValue_NoRTC(); //Display initial Date & Time values
    //-------------------------

    //Run a series of setups to initialize RTC values
    RunDateSetup();
    RunTimeSetup();
    RunAlarmSetup();

    //Set the current time & day set by the user on RTC chip
    SetTimeDate(time_sec, time_min, time_hour, 0, date_day, date_month, date_year);

    //Alert user, the alarm and time has been set.
    clearLCD();
    writeMessage("-Setup completed", 16);
    setCursorPosition(0x40); //Jump to second line
    writeMessage("& alarm set-", 12);
    setDelay(2000); //2s delay
    clearLCD();

    //Main Loop
    while(true) {

    	switch(CLOCK_STATE){
			case 1: //Clock & Alarm running
				//Select the info that will be displayed on LCD
				switch(CURRENT_DISPLAY_INFO){
					case 0:
						DisplayCurrentRTCValue();
						break;
					case 1:
						DisplayCurrentAlarmValue();
						break;
				}

				//Check if alarm has to be triggered
				if((time_sec == alarm_sec) && (time_min == alarm_min) &&  (time_hour == alarm_hour)){
					//All LCD messages should be written first before turning on buzzer in order to avoid LCD vs. Buzzer interference
					//Write alarm message on LCD
					clearLCD();
					DisplayCurrentAlarmValue();
					setCursorPosition(0x00);
					writeMessage("ALARM TRIGGERED ", 16);
					//Turn ON buzzer
//					PWMOutputState(PWM1_BASE, PWM_OUT_0_BIT, true);
					PWMOutputState(PWM1_BASE, PWM_OUT_5_BIT, true);
					//Jump to alarm clock state
					CLOCK_STATE = 2;
				}
				break;

			case 2: //Alarm active
				if(ENTER_PUSH_FLAG){
					//Turn OFF buzzer & return to STATE 1
//					PWMOutputState(PWM1_BASE, PWM_OUT_0_BIT, false);
					PWMOutputState(PWM1_BASE, PWM_OUT_5_BIT, false);
					ENTER_PUSH_FLAG = false;
					CLOCK_STATE = 1;
				}
				break;
    	}
    }
}
